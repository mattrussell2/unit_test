#!/bin/python3
import sys
import os
import shutil
import subprocess

# make build directory to for unit_test
def mkbuild():
    # remove previous build folder if it exists
    if 'build' in os.listdir('./'):
        shutil.rmtree('./build')
    
    os.mkdir('./build/')
    shutil.copytree('bin', './build/bin/')
    shutil.copytree('lib', './build/lib/')

# set the python path inside the unit_test script
def set_python_path():
    pythonpath = input(
      """
Welcome to unit_test! A frictionless C++ unit testing framework.

This script will move the necessary files to the proper locations for unit_test to work.

unit_test requires Python3.7 or newer to run. 

There is a copy of it on the Tufts CS server at /g/15/2020uc/support/bin/Python3.7

This script will default to using that location. 

Do you have another Python executable >= 3.7 in mind? 

If so, please enter the full file path now (as in the above example)

(Otherwise just press RETURN): """)

    if not pythonpath == "":
        fstrreplace('./build/bin/unit_test',
                    "#!/g/15/2020uc/support/bin/python3.7",
                    "#!" + pythonpath)

# copy the bin and lib files to their appropriate directories           
def copyfiles(local, libpath=None):
    if local == 'bin':  ftype = 'executable'
    else:               ftype = 'library'
    
    path = input(
                 "\nGreat! Where would you like the " + ftype +
                 " files to live? \n(default is /comp/15/" + local + "/)" +
		 "\n(Note: please enter a full path [i.e. no ~/]): "
                )

    if path == "":
        path = "/comp/15/" + local + '/'

    if path[-1] != '/': path += '/'

    print("\nsetting path to: " + path)
        
    if local == 'bin':
        # set the driverfile path in the unit_test script to the lib path
        fstrreplace('./build/bin/unit_test', '/comp/15/lib/', libpath)

        # set the correct bin path in the install script
        fstrreplace('./build/bin/install_unit_test', "/comp/15/bin/", path)

    try:
        for f in os.listdir('./build/' + local):
            shutil.copyfile('./build/' + local + '/' + f, path + f)
        
    except OSError:
        ans = input(path + \
                " does not exist. Would you like me to create it for you? (y/n): ")
        if ans[0] == 'y':
            try:
                os.makedirs(path)
                for f in os.listdir('./build/' + local):
                    shutil.copyfile('./build/' + local + '/' + f, path + f)
            except:
                cleanup(success=False)
        else:
            cleanup(success=False)
                    
    return path

# given a file, replace all instances of the original text with the new text
def fstrreplace(location, original, new):
    with open(location, 'r') as f:
        currfile = f.read()
       
    currfile = currfile.replace(original, new)

    with open(location, 'w') as f:
        f.write(currfile)
    
# exit with 0 or 1
def cleanup(success=True):
    if success:
        print("Setup complete!")
        sys.exit(0)
    else:
        print("Setup not complete. Please try again.")
        sys.exit(1)
        
if __name__ == '__main__':
    mkbuild()
    set_python_path()
    libpath = copyfiles('lib')
    binpath = copyfiles('bin', libpath)
    
    print("\nGreat! Files have been copied successfully. Setting up permissions...\n")

    subprocess.run(['chmod', '-R', '775', binpath])
    subprocess.run(['chmod', '-R', '774', libpath])

    print("Permissions have been set for executable and library paths.\n")

    print("Setup of unit_test in the specified directories is complete.\n")
    
    ans = input("Would you like to install unit_test for yourself? (y/n) ")

    if ans[0] == 'y':
        subprocess.run(['./build/bin/install_unit_test'])
    
    cleanup(success=True)
    


   
   
